
Racket installed target directories are like below:

  [e] Executables    /usr/local/bin (exists)
  [o] Libraries      /usr/local/lib/racket (will be created)
  [s] Shared files   /usr/local/share/racket (will be created)
  [c] Configuration  /usr/local/etc/racket (will be created)
  [d] Documentation  /usr/local/share/racket/doc (will be created)
  [a] .desktop files /usr/local/share/applications (exists)
  [m] Man Pages      /usr/local/share/man (exists)
  [l] C Libraries    /usr/local/lib (exists)
  [h] C headers      /usr/local/include/racket (will be created)

Racket document (run raco docs can open local installed docs):

  * Racket documentation (https://docs.racket-lang.org/)
  * Racket quick introduction with pictures ($DOCS/quick/index.html)
  * The Racket guide ($DOCS/guide/index.html)
  * The Racket reference ($DOCS/reference/index.html)



The Racket Quick Guide
----------------------

Racket 中的标识符，除了不能使用这些字符 ( ) [ ] { } " , ' ` ; # | \ 以及对
应的字符序列表示的不是一个数字外，可以是由任何非空白字符组成的字符序列。


 | Definitions and Local Bindings


(define <name> <expr>)
(define (<name> <args>) <body>)
(define ((<name> <args-without-default-value>)
         (<default-value-arg> <default-value>) ...) <body>)
(define-values (<name> ...) (values <value> ...))

    (define x 12)
    x                                           -> 12
    (define (g) 100)
    (g)                                         -> 100
    (define (f a b) (+ a b))
    (f 1 2)                                     -> 3
    (define-values (x y z) (values 1 2 3))
    y                                           -> 2
    z                                           -> 3
    (define ((f a) (b 10) (c 20)) (+ a b c))
    ((f 10))                                    -> 40
    ((f 10) 20)                                 -> 50
    ((f 10) 20 30)                              -> 60


(let ((<name> <value>)
      (<name> <value>)
      ...)
     <body>)
(let <body-proc> ((<name> <value>)
                  (<name> <value>)
                  ...)
                 <body>)
(let* is like let, but <value> is evaluated and the <name>'s location is
 created one by one from left to right, so the name of current value can
 be used in next value expressions; about let, its <name>s location are
 created only after all <value>s are evaluated)
(letrec is like let, but all <name>s' location are created first, so all
 <name>s can be referenced anywhere in the letrec, only if they are referenced
 not evaluated at the time, typically they are used in lambda body, because
 they are not evaluated at the time lambda definition, only evaluated when
 lambda is called later)
(let-values (((<name> ...) (values <value> ...))
             ((<name> ...) (values <value> ...))
             ...)
            <body>)
(let*-values ...)
(letrec-values ...)

    (let ((x 1)
          (y 2))
         (+ x y))                                    -> 3
    (let fac ((n 3))
             (if (zero? n)
                 1
                 (* n (fac (- n 1)))))               -> 6
    (let* ((x 1)
           (y (+ x 2)))
          (+ x y))                                   -> 4
    (letrec ((even? (lambda (n) (or (zero? n) (odd? (- n 1)))))
             (odd? (lambda (n) (not (even? n)))))
            (odd? 11))                               -> #t
    (let-values (((a b c) (values 1 2 3))
                 ((x y) (quotient/remainder 10 3)))
                (+ a b c x y))                       -> 10


 | Pairs and Lists

函数 cons 可以组装两个值形成一个二元组（pair），由 cons 构造的值用 pair? 判
断都为真；列表 (list）是由 pair 形成的单链表，其中每个 pair 的第二个值又都
是一个 pair，最后一个 pair 的第二个值是一个空值，表示链表的结束，相当于 C
语言中单链表最后的空指针。这个空值使用 '() 或 empty 表示，规定为是一个空
表，即用 list? 和 null? 判断都为真，但用 pair? 判断不为真，因为实际上这个
是单独的一个值，不是二元组。

列表有简写形式，如下第一列是原本的构造方式，后两列是简写：
空表：         empty                             (list)        '()
一个元素列表： (cons 1 empty)                    (list 1)      '(1)
两个元素列表： (cons 1 (cons 2 empty))           (list 1 2)    '(1 2)
三个元素列表： (cons 1 (cons 2 (cons 3 empty)))  (list 1 2 3)  '(1 2 3)

二元组也有简写形式，每当使用两个值来构造一个二元组时，使用一个括号括起这
两个值，并在这两个值之间使用点号（.）隔开，就是一个二元组的表达形式，如：
'(1 . 2)        第一个值是 1，第二个值是 2
'((1 . 2) . 3)  第一个值是二元组 '(1 . 2)，第二个值是 3
'(1 . (2 . 3))  第一个值是 1，第二个值是二元组 '(2 . 3)

其实，列表的简写形式是对二元组简写形式的化简：
'(1 . (2 . (3 . ()))) 第一个值是 1，第二个值是二元组 '(2 . (3 . ()))
这个二元组 '(2 . (3 . ())) 的第一个值是 2，第二个值是二元组 '(3 . ())
这个二元组 '(3 . ()) 的第一个值是 3，第二个是空表 。
可以看出上面的二元组实际上是列表 '(1 2 3)，可以对上面二元组形式化简得到
简单的列表表达形式，化简的规则是点号（.）和后面的一对匹配的括号可以同时
消掉，看下面的化简过程。

原本二元组表示： '(1 . (2 . (3 . ())))
消去第一个点号： '(1 2 . (3 . ()))
消去第二个点号： '(1 2 3 . ())
消去第三个点号： '(1 2 3)

实际上任何可以化简的二元组在 Racket 的打印输出中都已经化简了，例如输入上
面的列表二元组表示会直接打印出 '(1 2 3) ，再如前面例子中的 '(1 . (2 . 3))
会打印 '(1 2 . 3) 。



The Racket Reference
--------------------
by Matthew Flatt and PLT




## 第1章 构造过程抽象（整理进行中...）

本章主要内容
* 程序由表达式构成
* 构建复杂程序的方法
* 过程和求值
* 递归和迭代
* 高阶过程

**天地伊始，混沌初开，上帝创造了表达式**

起初，程序世界只有最简单的基本表达式，是懒惰的上帝赋予这个世界的初态和原本。也就是说，这个时候，四则运算那些家伙 （"+"、"-"、"*”、"/”）还只能暴走裸奔，俨然不知道出生是为了什么，裸奔到底要去哪里。横空出世的数字家族（"1”、“2”、“13”、“3.14” 等）也同样萌蠢不可救药，摸着自己阿拉伯数字的身体，傻傻发楞。夏娃看着混乱的一切，只有失望，便毅然行使权利，创造出程序世界的三大定律：

一、基本表达式由基本数据和基本过程组成  
二、基本表达式可以通过组合的方法形成复杂表达式  
三、复杂表达式可以通过抽象的方法当做基本表达式使用  

自此，世界开始风云变幻，每个基本个体通过组合的方法形成复杂个体，复杂个体通过抽象的方法重获自由，继续组合新的更复杂个体。生机勃勃的世界诞生了，夏娃心满意足，但一看旁边无所事事的亚当，就气不打一处来。片刻之后，亚当便成了定律代言人，为我们这些愚蠢的人类解释这些定律到底是怎么回事。亚当花了整整七七四十九个日夜又三天，为人类编纂了一部《创世录》，是为创世第一书。

《创世录》第一卷第一章 基本法

基本表达式包括基本数据和基本过程。基本数据包括布尔值、数字、字符、字符串（string）、符号（symbol）等。基本过程包括加（+）、减（-）、乘（*）、除（/）、大于（>）、小于（<）、等于（=）、逻辑与（and）、逻辑或（or）、逻辑非（not）等。组合的方法有定义变量、定义过程、组成条件表达式、组成lambda表达式、组成let表达式等。抽象的方法，即变量定义表达式定义的变量名、过程定义表达式定义的过程名，可以当作基本表达式使用。基本表达式形成复杂表达式，复杂表达式和基本表达式一起形成更复杂表达式，表达式构成程序。

布尔值

| 布尔值      | 书写形式
| -------     | -----
| 真（true）  | #t
| 假（false） | #f







程序基本元素
```
程序包含两大要素，过程和数据，数据是待处理信息，而过程是对如何处理信息的详尽描述，它指挥并控制计算机如何运转
Lisp 中的过程和数据都使用*表达式*描述，Lisp 中的一切都是表达式，表达式可以由简入繁形成复杂程序
强大的编程语言都有将简单认知组合成复杂认知的能力，它涉及三种机制
基本表达式－即语言关心的最简单个体的表示方法，如 Lisp 中的基本过程 + - * / 和基本数据 42、3.14 等
组合的方法－能将简单个体构造出复杂个体
抽象的方法－能将复杂个体命名，然后像简单个体那样操作它们
基本表达式可以通过组合的方法形成复杂表达式，复杂表达式又可以通过抽象的方法抽象成基本表达式那样使用
如此反复，简单可以变复杂，复杂可以抽象成简单，这复杂的简单又可以变成更高层次的复杂，而形成复杂强大的程序
```

基本表达式
```
数值数据 486、3.14 等
字符数据 'abcdefgh
布尔值 #f #t
基本过程 + - * /
基本谓词 > = <
复合谓词 and or not
抽象方法 define
名字标识符
```

组合式
```
基本表达式可以形成组合表达式，称为组合式，它用括号将多个表达式组合在一起 (<oper> <expr> <expr> ...)
其中最左边的表达式是运算符，其他表达式是运算对象，将运算符应用于运算对象所算得的结果是组合式的值
一些简易的例子如 (+ 10 30)、(- 100 80)、(* 5 8)、(/ 2.7 10) 对应的值是四则运算的计算结果
运算符和运算对象的这种书写形式（将运算符放到最左边）称为前缀式，这种方式的优点是运算对象可以有任意多个
前缀式的第二个优点是，它可以直接嵌套扩充，例如 (+ (* 3 5 7) (- 10 20 (+ 2 4)) (/ 25 4 12))
原则上讲，对于这种嵌套深度和 Lisp　解释器可以求值的表达式复杂度，是没有限制的，倒是我们自己可能会被搞糊涂
为了书写方便，Lisp 的编辑器一般都提供了美观打印的自动缩进和括号匹配功能，这让复杂表达式的结构变得清晰
```

Lisp 遵循一种约定，规定每个表达式都有一个值，这一约定和有关 Lisp 是一个低效语言的陈旧说法一起，形成了 Alan Perlis 的妙语（由 Oscar Wilde 释义）：“Lisp 程序员知道所有东西的值（value，价值），但却不知道任何东西的代价（cost）。”

定义变量和过程
```
变量定义的一般形式 (deinfe <name> <expr>)
过程定义的一般形式 (define (<name> <parameters>) <body>)
过程体 <body> 是一个表达式，实际上可以是一系列表达式，最后一个表达式的值是结果
一个过程可以没有参数，例如 (define (get-zero) 0)
```

简单示例
``` lisp
> (define size 2)
> size
2
> (* 5 size)
10
> (define pi 3.14159)
> (define radius 10)
> (* pi radius radius)
314.159
> (define c (* 2 pi radius))
> c
62.8318
> (define (square x) (* x x))
> (square 21)
441
> (square (+ 2 5))
49
> (square (square 3))
81
> (define (sum-of-squares x y) (+ (square x) (square y)))
> (sum-of-squares 3 4)
25
> (define (get-zero) 0)
> (get-zero)
0
```

组合式求值
```
求该组合式中所有子表达式的值
将最左表达式的值对应的操作应用于运算对象，最后算得的值即为该组合式的值
还有一种求值方法是先不求出运算对象的值，而用运算对象表达式代换操作的参数进行展开
直到最后得到一个只包含基本运算符的表达式，然后再去执行求值
这种“完全展开而后归约“的求值模型称为正则序求值，与之对应的”先求值参数而后应用”的模型称为应用序求值
正则序求值的例子 (square (+ 1 2)) => (* (+ 1 2) (+ 1 2)) => (* 3 3) => 9
应用序求值的例子 (square (+ 1 2)) => (square 3) => (* 3 3) => 9
可以证明，对那些可以通过替换去模拟并能产生出合法值的过程，正则序和应用序所得的结果是相同的
Lisp 采用应用序求值，部分原因在于这样做能避免表达式的重复求值，而提高效率
更重要的是，在超出了可以采用替换方式模拟的过程范围之后，正则序的处理将变得非常复杂
而另一方面，正则序可以称为特别有用的工具，我们将在后面章节研究它的某些内在性质
```

条件表达式

``` lisp
(cond (<pred1> <expr1>) (<pred2> <expr2>) ... (<predn> <exprn>))
条件表达式以 cond 开始，然后跟随多个子句，每个子句包含一个谓词和一个表达式
我们用术语谓词表示哪些返回真或假的过程，或能求出真或假的值的表达式
Scheme 中存在两个特殊的值，它们分别用常量 #t 和 #f 表示
当解释器检查一个谓词的值时，它将 #f 解释为假，而将所有其他值都解释为真
这样，提供的 #t 在逻辑上是不必要的，只是为了方便而已
例如求绝对值的过程使用了基本谓词 < = >，(define (abs x) (cond ((> x 0) x) ((= x 0) 0) ((< x 0) (- x))))
条件表达式的求值方式是先对谓词 <pred1> 求值，如果值为假则继续对谓词 <pred2> 求值
直到找到值为真的谓词为止，此时解释器返回对应子句的 <expr> 表达式的值
如果无法找到值为真的 <pred>，该 cond　条件表达式的值就没有定义
求绝对值的过程的另一种写法是 (define (abs x) (cond (（< x 0) (- x)) (else x)))
else 可以用在最后一个子句中，当所有子句都不满足条件时会求这个子句的值
事实上，所有永远都求出真值的表达式都可以用在这个子句的 <pred> 位置上
条件表达式的受限形式 (if <pred> <expr1> <expr2>)，仅能用于只有两种情况的需求
另外，受限的条件表达式形式中的 <expr> 只能是单个表达式，而 cond 中的 <expr> 可以是一系列表达式
除了基本谓词 < = > 之外还有三个复合谓词 (and <expr1> ... <exprn>)，(or <expr1> ... <exprn>)，(not <expr>)
注意的是 and 和 or 都是特殊形式的而不是普通的过程，因为它们的子表达式不一定都求值，而 not 是一个普通过程
```

过程的内部结构
```
过程的形参是过程体里的局部名字，仅在这个过程里可见
一些过程仅辅助其他过程的实现，这些过程不需要对用户可见，可定义在目标过程的过程体内
这种将子过程局部化的好处是，子过程名称不会污染外部名字空间，也不会像多余的过程那样对用户使用目的过程造成干扰
这种机制对大型程序设计是很重要的，每个过程都可以有自己独立子过程实现，便于过程之间相互独立从而实现程序模块化，是组织大型程序结构的重要工具
这种嵌套定义称为块结构，它是最简单的名字包装问题的一种正确解决方式
实际上，这里还隐藏着一个很好的想法，除了可以将所用的辅助过程定义放在内部，我们还可能简化它们
由于过程的形参是过程的局部名字，对里面的子过程都是可见的，显式地将这些参数在过程之间传来传去也就没有必要了
如果嵌套的子过程需要用到这些参数，直接使用它们就可以了，参数的这种使用方法称为词法作用域
词法作用域的实现机制是，如果过程中出现了没有在该过程中定义的名称，应该到定义本过程所在的环境中去寻到它们，这里嵌套子过程的环境指的是包含它们的外部过程
嵌套的定义必须出现在过程体之前，如果我们运行一个程序但是其中的定义与使用混杂在一起，管理程序将不负任何责任
```

过程的嵌套语法

``` lisp
(define (<masterproc> <parameters)
  (define (<subproc1> <parameters>) <body>)
  (define (<subproc2> <parameters>) <body>)
  ...
  (define (<subprocn> <parameters>) <body>)
  <masterproc-body>
  )
```

递归与迭代

阶乘为例 n! = n * (n-1) * (n-2) * ... * 1，一种实现方式是：

``` lisp
(define (factorial n)
  (if (= n 1)
      1
      (* n (factorial (- n 1)))
  )
)
```

其展开求值的过程如下：

``` lisp
(factorial 3)
(* 3 (factorial 2))
(* 3 (* 2 (factorial 1)))
(* 3 (* 2 1))
(* 3 2)
6
```

另一种不同视角的实现方式是求n次值，并维持一个变动的乘积结果：

``` lisp
(define (factorial n)
  (define (subproc product step)    ; step is from n to 1
    (if (= step 1)
        product
        (subproc (*　product step) (- step 1))
    )
  )
  (subproc 1 n)
)
```

其展开求值的过程是：

``` lisp
(factorial 3)
(subproc 1 3)
(subproc 3 2)
(subproc 6 1)
6
```

可以发现同样求阶乘，两种方法的求值方式完全不同，第一种方法是先逐步展开而后收缩的形态。在展开的阶段中，这一过程构造起一个推迟求值的链条（如上面的乘法链条），收缩阶段表现为运算的实际求值。这种类型的计算过程由一个推迟执行的运算链刻画，称为一个递归计算过程。要执行这种计算过程，解释器需要维护那些以后将要执行的操作的轨迹。例如上面的阶乘，推迟执行的链条长度就是保存其轨迹所需要的信息量。这个长度随 n 线性增长（即正比于n），这样的过程我们称它为一个线性递归过程。

而第二种方法的展开形式中没有任何的增长和收缩，所需要保存的仅仅是变量 product 和 step 的值，我们称这种过程为迭代计算过程。一般来说，迭代计算过程就是那种其状态可以用固定数目的状态变量的计算过程；且与此同时还存在这一套固定的规则，描述了计算过程在从一个状态到下一个状态转换时，这些变量的更新方式；另外还有一个可能的结束检测，它描述这一计算过程应该终止的条件。在计算阶乘时，计算所需的步骤随着 n 线性增长，这种过程我们称为线性迭代过程。

我们还可以从另外一个角度看这两个过程之间的不同。在迭代情况下，计算过程中的任意一点，那两个程序变量都提供了有关计算状态的完整描述。如果我们令上述计算在某两个步骤之间停下来，要想重新唤醒这一计算，只需为解释器提供有关这两个变量的值。而对递归计算过程而言，这里还存在着另外一些“隐含”信息，它们并未保存在程序变量中，而是由解释器维持着，指明了在所推迟的运算所形成的链条里的漫游中，“这一计算过程处在何处”。这个链条越长，需要保存的也就越多。

在第5章中我们将要讨论过程在寄存器机器上的实现，那时将看到所有的迭代过程都可以“以硬件的方式”实现为一个机器，其中只有固定数目的寄存器，无须任何辅助存储器。与这种情况不同，要实现递归计算过程，就需要一种机器，其中使用了一个称为堆栈的辅助数据结构。

在做迭代与递归之间做比较时，不要搞混了递归计算过程和递归过程的概念。当我们说一个过程是递归的时候，论述的是一个语法形式上的事实，说明这个过程的定义中（直接或间接）调用该过程本身。在收某种计算过程具有某种模式时，我们说的是这一计算过程的进展方式，而不是相应过程语法上的书写形式。

当我们说某个递归过程将产生一个迭代计算过程时，可能使人感到不舒服。然而这一计算过程确实是迭代的，因为它的状态能有其中的几个状态变量完全刻画，解释器在执行这一计算过程时，只需保存这几个状态就够了。区分计算过程和写出的过程可能使人感到困惑，其中一个原因在于各种常见语言的大部分实现的设计中，对于任何递归过程的解释，所需要消耗的存储量总与过程调用的数目成正比，即使它所描述的计算过程从原理上看是迭代的。

作为这一事实的后果，要在这些语言中描述迭代过程，就必须借助于特殊的“循环结构”，如 do、repeat、until、for 和 while 等等。我们将在第5章考察Scheme的实现则没有这一缺陷，它将总能在常量空间中执行迭代型计算过程，即使这一计算是用一个递归过程描述的。具有这一特性的实现称为尾递归的。有了一个尾递归的实现，我们就可以利用常规的过程调用机制表述迭代，这也会是各种复杂的专用迭代结构变成不过是一些语法糖衣了。

另一种常见的计算模型是树形递归，斐波那契数列的计算就是一个例子，这一序列中的每个数都是前面两个数之和:

``` lisp
(define (fibonacci n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fibonacci (- n 1)) (fibonacci (- n 2))))
  )
)
```

其计算的展开形式为：

``` lisp
(fibonacci 3)
  /                                         \
(finonacci 2)             +              (fibonacci 1)
     /              \                          \
(finonacci 1)  +  (finonacci 0)     +          1
      /               \
     1                  0
```

这里每一次的调用都分裂为两个分支，反映出对两次递归调用自身的事实。上面的过程作为典型的树形递归具有教育意义，但它却是一种很糟糕的计算斐波那契数列的方法，因为它做了太多的冗余计算。这样，该过程所用的计算步骤将随着输入呈现指数级增长。一般说，树形递归计算过程所需的步骤数将正比于树的结点数，其空间需求正比于数的最大深度。

我们也可以规划出计算斐波那契数列的迭代过程，其基本思想是利用变量 a 和 b　动态保存计算过程的中间值：

``` lisp
(define (fibonacci n)
  (define (subproc a b n)
    (if (= n 0)
        a
        (subproc b (+ a b) (- n 1))
    )
  )
  (subproc 0 1 n)
)
```

这种迭代计算过程将比树形递归过程快得多，但我们不应做出结论，说树形递归计算过程根本没用。当我们考虑的是在层次结构数据上的操作时，将会发现树形递归计算过程是一种自然的、威力强大的工具。

要点梳理
```
迭代和递归的关键区别在于计算过程需要保存的状态的数目是否是固定的
以阶乘为例，推迟运算链条需要保存的信息随 n 线性增长，因而是一个递归过程
而第二种方法，不论 n 多大都只需保存两个中间状态的值，因而是一个迭代过程
递归过程根据链条的长度的性质，有线性递归过程、树形递归过程等
迭代过程根据计算所需步骤的数目，有线性迭代过程等
```

高阶过程

在作用上，过程也是一类抽象，它们描述对于数的一系列操作，但又不依赖与特定的数。例如定义 (define (cube x) (* x x x) 时我们讨论的并不是某个特定数值的立方，而是对任意的数得到其立方的方法。立方这个过程是对具体的数立方的抽象，如果没有这种抽象，对于立方每个具体计算，我们都只能这样细节无疑的写出来，如 (* 3 3 3)、(* 3.14 3.14 3.14)、(* 123 123 123)。显然这样是非常琐碎的、低效的、会将所有的操作都打回到原始操作上，不仅无法无尽的重复，也几乎无法用来开发大型程序。

因此程序设计语言都必然提供了建立的抽象的方法，为抽象命名，然后在抽象层次上继续抽象的能力。然而，即使在数值的计算过程中，如果将过程限制为只能以数作为参数，那也会严重地限制我们建立抽象的能力。经常有一些同样的程序设计模式能用于若干不同的过程，为了把这种模式描述为相应的概念，我们就需要构造出这样的过程，让它们以过程作为参数，或者以过程作为返回值。这些能操作过程的过程称为高阶过程。高阶过程是一种强有力的抽象机制，极大地增强了语言的表达能力。

下面几个过程，一个是a到b整数求和：

``` lisp
(define (sum_ints a b)
  (if (> a b)
      0
      (+ a (sum_ints (+ a 1) b))
  )
)
```

给定范围内整数立方和：

``` lisp
(define (sum_cubes a b)
  (if (> a b)
      0
      (+ (cube a) (sub_cubes (+ a 1) b))
  )
)
```

显然这两个过程共享这某种基础模式，它们的很大一部分是相同的。我们可以抽象出这种形似性：

``` lisp
(define (sum a b calc next)
  (if (> a b)
      0
      (+ (calc a) (sum (next a) b))
  )
)
```

额外的参数 calc 用于从 a 算出需要加的项的过程，还有用于提供下一个 a 值的过程 next。实际上数学家很早就认识到了序列求和的抽象模式，并提出了专门的“求和记法”，例如 E{n=a,b}f(n) = f(a) + ... + f(b)。求和记法的威力在于它使数学家能去处理求和的概念本身。如此类似，通过允许将过程当做数据一样使用，高阶过程可以抽象出表述求和的概念。

有了求和的抽象，上面两个求和过程就可以写成:

``` lisp
(define (sum_ints a b)
  (define (calc x) x)
  (define (next x) (+ x 1))
  (sum a b calc next)
)

(define (sum_cubes a b)
  (define (calc x) (cube x))
  (define (next x) (+ x 1))
  (sum a b calc next)
)
```

为了将过程作为参数进行传递，上面的例子我们必须先定义出这些简单函数，这种做法看起来很不舒服。如果不需要显示定义这些函数，而是有一种方法去直接刻画这些函数的过程，事情就会方便很多。我们可以通过引入一个种 lambda 特殊形式完成这类描述，这种特殊形式能够创建出所需要的过程。实际上，lambda 可认为是匿名过程，除了没有名字（因为它定义之后拿来即用不需要名字）之外其他都与过程没有什么区别。实际上 (define (porc <parms>) <body>) 是与 (define proc　(lambda (<parms>) <body>)) 等价的。对于学习 Lisp 的人而言，如果用一个比 lambda 更明确的名字，比如 make-procedure，可能会觉得更清晰。但习惯成自然，这一记法取自 λ 演算，那是有数理逻辑学家丘奇 (Alonzo Church 1941)　引进的一种数字记法，为研究函数和函数应用提供了一个严格的基础。λ 演算已成为程序设计语言语义的数学基石。

有了 lambda 上面的过程就可以写成：

``` lisp
(define (sum_ints a b)
  (sum a b (lambda (x) x) (lambda (x) (+ x 1)))
)

(define (sum_cubes a b)
  (sum a b (lambda (x) (cube x)) (lambda (x) (+ x 1)))
)
```

Lambda 的另一个应用是创建局部变量，在一个过程里，除了使用哪些已经约束为过程参数的变量外，我们常常还需要另外一些局部变量。例如，假定我们希望计算函数 f(x,y) = x(1+xy)^2 + y(1-y) + (1+xy)(1-y)，可能希望表达成：a = 1+xy，b = 1-y，f(x,y) = xa^2 + yb + ab。这里用 a 和 b 表达的函数就是一个中间的过程：

``` lisp
(define (f x y)
  (define (help a b)
    (+ (* x (square a)) (* y b) (* a b))
  )
  (help (+ 1 (* x y)) (- 1 y))
)
```

使用 lambda 我们可以表述为：

``` lisp
(define (f x y)
  ((lambda (a b)
     (+ (* x (square a)) (* y b) (* a b))
   )
   (+ 1 (* x y))
   (- 1 y)
  )
)
```

这种结构非常有用，因此语言里有一个专门的特殊形式称为 let，使这种编程方式更为方便：

``` lisp
(define (f x y)
  (let ((a (+ 1 (* x y)))
        (b (- 1 y)
       )
       (+ (* x (square a)) (* y b) (* a b))
  )
)
```

let 表达式的一般形式是：

``` lisp
(let ((<var1> <expr1>)
      (<var2> <expr2>)
      ...
      (<varn> <exprn>)
     )
     <body>
)
```

它其实是如下 lambda 语法的替代形式：

``` lisp
((lambda (<var1> ... <varn>)
         <body>
 )
 <exp1>
 ...
 <expn>
)
```

因此 let 表达式只是作为其基础的 lambda 表达式的语法外衣罢了。根据这一等价关系，我们可以认为，由 let 表达式描述的变量的作用域就是该 let 的体，这也意味着：let 使人能尽可能接近其使用的地方建立局部变量的约束，例如下面的表达式 (+ (let ((x 3)) (+ x (* x 10))) x)，如果 x 的值是 5 那么结果是 38，这里 let 外的 x 是 5 而 let 内的 x 是 3；另外 let 定义的变量的值是 let 外计算的，这样 (let ((x 3) (y (+ x 2))) (* x y))，如果外部 x 是 2，那么 let 内部的 x 是 3，y 是 4。

以上例子说明，将过程作为参数传递，能够显著增强我们程序的表达能力。通过创建另一种其返回值本身也是过程的过程，我们还能得到进一步的表达能力。这种能力是根据过程的参数可以产生不同函数的能力，例如 ((average-damp square) 10)。一般而言，程序设计语言总会对计算元素的可能使用方式强加上某些限制。带有最小限制的元素被称为具有第一级的状态。第一级元素的某些“权利或者特权”包括：可以用变量命名；可以提供给过程作为参数；可以由过程作为结果返回；可以包含在数据结构中。Lisp 不想其他程序涉及语言，它给了过程完全的第一级状态。这就给 Lisp 的有效实现提供了挑战（实现第一级过程的主要代价是，为使过程能够作为值返回，我们就需要过程里的自由变量保留空间，即使这一过程并不执行，在 4.1 节有关 Scheme 实现的研究中，这些变量都被存储在过程的环境中），但由此所获得的描述能力却是极其惊人的。








